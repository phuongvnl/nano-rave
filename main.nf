#!/usr/bin/env nextflow

def printHelp() {
    log.info """
    Usage:
        nextflow run main.nf

    Options:
        --manifest                   Manifest containing paths to amplicon references (mandatory)
        --fastq_dir                  Path to directory containing nanopore base called fastq files (mandatory)
        --sample_name                Sample name - this will be the name of the prefix for all files generated by the pipeline (mandatory)
        --results_dir                Specify results directory - default nextflow_results (optional)
        --help                       Print this help message (optional)
    """.stripIndent()
}

def validate_parameters() {
    def errors = 0

    if (params.manifest) {
        manifest=file(params.manifest)
        if (!manifest.exists()) {
            log.error("The manifest file specified does not exist.")
            errors += 1
        }
    }
    else {
        log.error("No manifest file specified. Please specify one using the --manifest option.")
        errors += 1
    }

    if (params.fastq_dir) {
        fastq_dir_path=file(params.fastq_dir)
        if (!fastq_dir_path.exists()) {
            log.error("The fastq directory path specified does not exist.")
            errors += 1
        }
    }
    else {
        log.error("No fastq directory has been specified, please ensure you provide a value using the --fastq_dir option")
        errors += 1
    }

    if (!params.sample_name) {
        log.error("Please specify a sample name using the --sample_name option")
        errors += 1
    }

    if (!params.skip_qc) {
        if (params.sequence_summary_file) {
            sequence_summary_file=file(params.sequence_summary_file)
            if (!sequence_summary_file.exists()) {
                log.error("The sequence summary file specified does not exist.")
                errors += 1
            }
        }
        else {
            log.error("No sequence summary file specified. Please specify one using the --sequence_summary_file option.")
            errors += 1
        }
    }

    if (errors > 0) {
        log.error(String.format("%d errors detected", errors))
        exit 1
    }
}

process CAT_FASTQS {
    input:
        val(fastqs)
        val(sample_name)
    output:
        path("${fastq_file}"), emit: full_fastq_file
    script:
        fastq_file="${sample_name}.fastq.gz"
        """
        zcat ${fastqs}/*.fastq.gz > ${sample_name}.fastq
        gzip ${sample_name}.fastq
        """
}

process NANOPLOT_QC {
    publishDir "${params.results_dir}/qc/nanoplot", mode: 'copy', overwrite: true
    input:
        path(fastq_file)
    output:
        path("${nanoplot_qc_dir}/*")
    script:
        nanoplot_qc_dir="${params.sample_name}_nanoplot_qc"
        """
        NanoPlot -t 2 --fastq $fastq_file -o ${params.sample_name}_nanoplot_qc
        """

}

process PYCOQC {
    publishDir "${params.results_dir}/qc/pycoqc/${params.sample_name}", mode: 'copy', overwrite: true
    input:
        path(sequence_summary_file)
    output:
        path("*.html")
        path("*.json")
    script:
        """
        pycoQC -f $sequence_summary_file -o ${params.sample_name}_pycoqc.html -j ${params.sample_name}_pycoqc.json
        """
}

process GET_CHROM_SIZES_AND_INDEX {
    input:
        tuple val(ref_id), path(reference)
    output:
        tuple val(ref_id), path("*.sizes"), emit: sizes_ch
        tuple val(ref_id), path("*.fai"), emit: fasta_index_ch
        tuple val(ref_id), path(reference), emit: ref_ch
    script:
        """
        samtools faidx ${reference}
        cut -f 1,2 ${reference}.fai > ${reference}.sizes
        """
}

process MINIMAP2_INDEX {
    input:
        tuple val(ref_id), path(reference)
        tuple val(ref_id), path(sizes)
    output:
        path("*.mmi"), emit: mm2_index_ch
        tuple val(ref_id), path(reference), emit: ref_ch
        tuple val(ref_id), path(sizes), emit: sizes_ch
    script:
        """
        minimap2 -ax map-ont -t 2 -d ${reference}.mmi ${reference}
        """
}

process MINIMAP2_ALIGN {
    input:
        path(mm2_index)
        tuple val(ref_id), path(reference)
        path(fastq_file)
        tuple val(ref_id), path(sizes)
    output:
        path("*.sam"), emit: sam_file
        tuple val(ref_id), path(reference), emit: ref_ch
        tuple val(ref_id), path(sizes), emit: sizes_ch
    script:
        """
        minimap2 -ax map-ont --MD -t 2 $mm2_index $fastq_file > ${params.sample_name}_${ref_id}.sam
        """

}

process SAMTOOLS_VIEW_SAM_TO_BAM {
    input:
        path(sam_file)
        tuple val(ref_id), path(reference)
        tuple val(ref_id), path(sizes)
    output:
        path("*.bam"), emit: bam_file
        tuple val(ref_id), path(reference), emit: ref_ch
        tuple val(ref_id), path(sizes), emit: sizes_ch
    script:
        """
        samtools view -b -h -O BAM -@ 2 -o ${params.sample_name}_${ref_id}.bam $sam_file
        """
}

process SAMTOOLS_SORT_AND_INDEX {
    input:
        path(bam_file)
        tuple val(ref_id), path(reference)
        tuple val(ref_id), path(sizes)
    output:
        path("*.sorted.bam"), emit: sorted_bam
        path("*.sorted.bam.bai"), emit: sorted_bam_index
        tuple val(ref_id), path(reference), emit: ref_ch
        tuple val(ref_id), path(sizes), emit: sizes_ch
    script:
        """
        samtools sort -@ 2 -o ${params.sample_name}_${ref_id}.sorted.bam -T ${params.sample_name}_${ref_id} $bam_file
        samtools index ${params.sample_name}_${ref_id}.sorted.bam
        """
}

process BEDTOOLS_GENOMECOV {
    publishDir "${params.results_dir}/genome_coverage", mode: 'copy', overwrite: true, pattern: "*.bedGraph"
    input:
        path(sorted_bam_file)
        path(sorted_bam_index)
        tuple val(ref_id), path(sizes)

    output:
        path("*.bedGraph"), emit: genome_cov_ch

    script:
        """
        bedtools genomecov -split -ibam $sorted_bam_file -bg | bedtools sort > ${params.sample_name}_${ref_id}.bedGraph
        """
}

process SNIFFLES_VARIANT_CALLING {
    input:
        path(sorted_bam_file)
        path(sorted_bam_index)
        tuple val(ref_id), path(sizes)

    output:
        path("*.vcf"), emit: vcf_ch
        val(ref_id), emit: ref_id_ch

    script:
        """
        sniffles -m $sorted_bam_file -v ${params.sample_name}_${ref_id}.vcf
        # sort vcf by index to stop tabix crying
        cat ${params.sample_name}_${ref_id}.vcf | awk '\$1 ~ /^#/ {print \$0;next} {print \$0 | "sort -k1,1 -k2,2n"}' > ${params.sample_name}_${ref_id}_sorted.vcf
        mv ${params.sample_name}_${ref_id}_sorted.vcf ${params.sample_name}_${ref_id}.vcf
        """
}

process BGZIP_AND_INDEX_VCF {
    publishDir "${params.results_dir}/variant_calling", mode: 'copy', overwrite: true
    input:
        path(vcf_file)
        val(ref_id)

    output:
        path("*.vcf.gz"), emit: bgzip_vcf_file_ch
        path("*.vcf.gz.tbi"), emit: vcf_index_ch

    script:
        """
        bgzip -c $vcf_file > ${params.sample_name}_${ref_id}.vcf.gz
        tabix ${params.sample_name}_${ref_id}.vcf.gz
        """
}

workflow {
    if (params.help) {
        printHelp()
        exit 0
    }

    validate_parameters()

    manifest_ch = Channel.fromPath(params.manifest)
        ref_path_ch = manifest_ch.splitCsv(header: true, sep: ',')
            .map{ row -> tuple(row.reference_id, file(row.reference_path)) }


    CAT_FASTQS(params.fastq_dir, params.sample_name)

    if (!params.skip_qc) {
        sequence_summary_file = Channel.fromPath(params.sequence_summary_file)
        NANOPLOT_QC(CAT_FASTQS.out.full_fastq_file)
        PYCOQC(sequence_summary_file)
    }

    GET_CHROM_SIZES_AND_INDEX(ref_path_ch)

    MINIMAP2_INDEX(GET_CHROM_SIZES_AND_INDEX.out.ref_ch,
                   GET_CHROM_SIZES_AND_INDEX.out.sizes_ch)

    MINIMAP2_ALIGN(MINIMAP2_INDEX.out.mm2_index_ch,
                   MINIMAP2_INDEX.out.ref_ch,
                   CAT_FASTQS.out.full_fastq_file,
                   MINIMAP2_INDEX.out.sizes_ch)

    SAMTOOLS_VIEW_SAM_TO_BAM(MINIMAP2_ALIGN.out.sam_file,
                             MINIMAP2_ALIGN.out.ref_ch,
                             MINIMAP2_ALIGN.out.sizes_ch)

    SAMTOOLS_SORT_AND_INDEX(SAMTOOLS_VIEW_SAM_TO_BAM.out.bam_file,
                            SAMTOOLS_VIEW_SAM_TO_BAM.out.ref_ch,
                            SAMTOOLS_VIEW_SAM_TO_BAM.out.sizes_ch)

    BEDTOOLS_GENOMECOV(SAMTOOLS_SORT_AND_INDEX.out.sorted_bam,
                       SAMTOOLS_SORT_AND_INDEX.out.sorted_bam_index,
                       SAMTOOLS_SORT_AND_INDEX.out.sizes_ch)

    SNIFFLES_VARIANT_CALLING(SAMTOOLS_SORT_AND_INDEX.out.sorted_bam,
                             SAMTOOLS_SORT_AND_INDEX.out.sorted_bam_index,
                             SAMTOOLS_SORT_AND_INDEX.out.sizes_ch)

    BGZIP_AND_INDEX_VCF(SNIFFLES_VARIANT_CALLING.out.vcf_ch,
                        SNIFFLES_VARIANT_CALLING.out.ref_id_ch)
}

